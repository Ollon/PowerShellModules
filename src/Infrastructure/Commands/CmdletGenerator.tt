<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(USERPROFILE)\.nuget\packages\newtonsoft.json\11.0.2\lib\net45\Newtonsoft.Json.dll" #>
<#@ import namespace="Newtonsoft.Json" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    string path = @"..\Resources\cmdlets.json";
    path = System.IO.Path.GetFullPath(Host.ResolvePath(path));

    Cmdlets cmdlets = JsonConvert.DeserializeObject<Cmdlets>(System.IO.File.ReadAllText(path));

    foreach(Cmdlet cmdlet in cmdlets.cmdlets)
    {
        cmdlet.Init();
    }

    WriteMain(cmdlets);
    WriteCommands(cmdlets);

#>
<#+

    private void WriteCommands(Cmdlets cmdlets)
    {

        WriteLine("// <auto-generated />");
        WriteLine("namespace PowerShell.Infrastructure.Commands");
        WriteLine("{");
        PushIndent("    ");
        WriteLine("using PowerShell.Infrastructure.Utilities;");
        WriteLine("using PowerShell.Infrastructure.Fusion;");
        WriteLine("using Microsoft.Management.Infrastructure;");
        WriteLine("using System.Management.Automation;");
        WriteLine("");

        foreach(var cmdlet in cmdlets.cmdlets)
        {
            WriteCommand(cmdlet);
        }


        PopIndent();
        WriteLine("}");
    
    }

    private void WriteCommand(Cmdlet cmdlet)
    {
        WriteLine("");
        if (!string.IsNullOrEmpty(cmdlet.Alias))
        {
            WriteLine($"[Alias(\"{cmdlet.Alias}\")]");
        }
        Write($"[Cmdlet({GetClassName(cmdlet.Verb)}.{cmdlet.Verb}, {cmdlet.Noun}Name");
        if (cmdlet.Process)
        {
            Write(", SupportsShouldProcess = true");
        }
        if (cmdlet.Paging)
        {
            Write(", SupportsPaging = true");
        }
        WriteLine(")]");
        Write($"public partial class {cmdlet.Verb}{cmdlet.Noun}Command");
        if (cmdlet.Dynamic)
        {
            WriteLine(" : AbstractPSCmdlet, IDynamicParameters");
        }
        else
        {
            WriteLine(" : AbstractPSCmdlet");
        }
        WriteLine("{");
        PushIndent("    ");
        WriteLine($"private const string {cmdlet.Noun}Name = \"{cmdlet.Noun}\";");

        if (cmdlet.Params != null)
        {
            foreach(var parameter in cmdlet.Params)
            {
                if (!parameter.Dynamic)
                {
                    WriteLine("");
                    Write("[Parameter");

                    if (parameter.RequiresParenthesis)
                    {
                        Write("(");
                    }

                    bool comma = false;

                    if (parameter.Mandatory)
                    {
                        comma = true;
                        Write("Mandatory = true");
                    }
                    if (parameter.FirstPosition)
                    {
                        if (comma)
                        {
                            Write(", ");
                        }
                        Write($"Position = 0");
                        comma = true;
                    }

                    if (!string.IsNullOrEmpty(parameter.Set))
                    {
                        if (comma)
                        {
                            Write(", ");
                        }
                        Write($"ParameterSetName = \"{parameter.Set}\"");
                        comma = true;
                    }
                    if (parameter.ValueFromPipeline)
                    {
                        if (comma)
                        {
                            Write(", ");
                        }
                        Write($"ValueFromPipeline = true");
                        comma = true;
                    }
                    if (parameter.ValueFromPipelineByPropertyName)
                    {
                        if (comma)
                        {
                            Write(", ");
                        }
                        Write($"ValueFromPipelineByPropertyName = true");
                        comma = true;
                    }
                    if (parameter.ValueFromRemainingArguments)
                    {
                        if (comma)
                        {
                            Write(", ");
                        }
                        Write($"ValueFromRemainingArguments = true");
                    }
                    if (parameter.RequiresParenthesis)
                    {
                        Write(")");
                    }
                    WriteLine("]");
                    WriteLine($"public {parameter.Type} {parameter.Name} {{ get; set; }}");
                }
                else
                {
                    WriteLine($"protected bool {parameter.Name}ParameterSpecified");
                    WriteLine(@"{");
                    PushIndent("    ");
                    WriteLine(@"get");
                    WriteLine(@"{");
                    PushIndent("    ");
                    WriteLine($"return MyInvocation.BoundParameters.ContainsKey(\"{parameter.Name}\");");
                    PopIndent();
                    WriteLine(@"}");
                    PopIndent();
                    WriteLine(@"}");
                    WriteLine(@"");
                    WriteLine($"protected {parameter.Type} {parameter.Name}ParameterValue");
                    WriteLine(@"{");
                    PushIndent("    ");
                    WriteLine(@"get");
                    WriteLine(@"{");
                    PushIndent("    ");
                    WriteLine($"return ({parameter.Type}) DynamicParameters[\"{parameter.Name}\"].Value;");
                    PopIndent();
                    WriteLine(@"}");
                    PopIndent();
                    WriteLine(@"}");

                }

            }

            
        }


        WriteLine("");
        WriteLine("");
        WriteLine($"public override string ToString() => PowerShellFactory.{cmdlet.Verb}{cmdlet.Noun}Cmdlet;");
        PopIndent();
        WriteLine("}");
    }

    private void WriteMain(Cmdlets cmdlets)
    {
        WriteLine("// <auto-generated />");
        WriteLine("namespace PowerShell.Infrastructure");
        WriteLine("{");
        PushIndent("    ");

        WritePowerShellFactory(cmdlets);

        PopIndent();
        WriteLine("}");
    }


    private void WritePowerShellFactory(Cmdlets cmdlets)
    {
        WriteLine("internal static partial class PowerShellFactory");
        WriteLine("{");
        PushIndent("    ");

        HashSet<string> list = new HashSet<string>();

        foreach(var cmdlet in cmdlets.cmdlets)
        {
            if (list.Add(cmdlet.Noun))
            {
                WriteLine($"public const string {cmdlet.Noun} = \"{cmdlet.Noun}\";");
            }
            WriteLine($"public const string {cmdlet.Verb}{cmdlet.Noun}Cmdlet = \"{cmdlet.Verb}-{cmdlet.Noun}\";");

        }

        PopIndent();

        WriteLine("}");
    }

    private static string GetClassName(string verb)
    {
        switch(verb)
        {
            case "Add":
            case "Clear":
            case "Close":
            case "Copy":
            case "Enter":
            case "Exit":
            case "Find":
            case "Format":
            case "Get":
            case "Hide":
            case "Lock":
            case "Move":
            case "New":
            case "Open":
            case "Optimize":
            case "Push":
            case "Pop":
            case "Remove":
            case "Rename":
            case "Reset":
            case "Resize":
            case "Set":
            case "Search":
            case "Show":
            case "Skip":
            case "Step":
            case "Join":
            case "Redo":
            case "Split":
            case "Switch":
            case "Select":
            case "Undo":
            case "Unlock":
            case "Watch":
                return "VerbsCommon";
            case "Send":
            case "Receive":
            case "Connect":
            case "Disconnect":
            case "Write":
            case "Read":
                return "VerbsCommunication";
            case "Backup":
            case "Checkpoint":
            case "Compare":
            case "Compress":
            case "Convert":
            case "ConvertFrom":
            case "ConvertTo":
            case "Edit":
            case "Expand":
            case "Export":
            case "Group":
            case "Import":
            case "Initialize":
            case "Limit":
            case "Merge":
            case "Publish":
            case "Restore":
            case "Save":
            case "Sync":
            case "Unpublish":
            case "Update":
            case "Mount":
            case "Dismount":
            case "Out":
                return "VerbsData";
            case "Debug":
            case "Measure":
            case "Ping":
            case "Repair":
            case "Resolve":
            case "Test":
            case "Trace":
                return "VerbsDiagnostic";
            case "Approve":
            case "Assert":
            case "Complete":
            case "Confirm":
            case "Deny":
            case "Disable":
            case "Enable":
            case "Install":
            case "Invoke":
            case "Register":
            case "Request":
            case "Restart":
            case "Resume":
            case "Start":
            case "Stop":
            case "Submit":
            case "Suspend":
            case "Uninstall":
            case "Unregister":
            case "Wait":
                return "VerbsLifecycle";
            case "Use":
                return "VerbsOther";



            default: throw new ArgumentException();
        }
    }


    public class Cmdlets
    {
        public List<Cmdlet> cmdlets { get; set; }
    }

    public class Cmdlet
    {
        public string Verb { get; set; }

        public string Noun { get; set; }

        public string Alias { get; set; }

        public bool Process { get; set; }

        public bool Paging { get; set; }

        public bool Dynamic { get; set; }

        public bool Transactions { get; set; }

        public string ParameterSet { get; set; }

        public List<Parameter> Params { get; set; }

        public void Init()
        {
            for (int i = 0; i < Params.Count; i++)
            {
                Params[i].Id = i;
            }
        }
    }

    public class Parameter
    {
        public int Id { get; set; }

        public bool FirstPosition { get; set; }

        public string Name { get; set; }

        public string Type { get; set; }

        public bool Dynamic { get; set; }

        public string Set { get; set; }

        public bool Mandatory { get; set; }

        public bool ValueFromPipeline { get; set; }

        public bool ValueFromPipelineByPropertyName { get; set; }

        public bool ValueFromRemainingArguments { get; set; }

        public bool RequiresParenthesis 
        {
            get
            {
                return !string.IsNullOrEmpty(Set) 
                || Mandatory 
                || ValueFromPipeline
                || ValueFromPipelineByPropertyName
                || ValueFromRemainingArguments;
            }
        }
    }


#>











